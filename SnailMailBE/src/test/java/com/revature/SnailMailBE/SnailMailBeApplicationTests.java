package com.revature.SnailMailBE;

import com.revature.SnailMailBE.models.Mail;
import com.revature.SnailMailBE.models.User;
import com.revature.SnailMailBE.services.MailService;

import io.restassured.filter.log.RequestLoggingFilter;
import io.restassured.filter.log.ResponseLoggingFilter;
import io.restassured.response.Response;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import io.restassured.RestAssured;
import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.mockito.ArgumentMatchers.any;

@SpringBootTest
@AutoConfigureMockMvc //<- IMPORTANT - This sets up MockMVC so we can send mock requests
class SnailMailBeApplicationTests {

	//Some setup first

	//Mock MailService -
	//we'll use this to test the controller without calling real service methods
	@MockitoBean
	private MailService mockMailService;

	//This object will help us write mock HTTP requests -
	//so we can test strictly the controller logic, not depending on HTTP
	@Autowired
	private MockMvc mockMvc;

	@BeforeAll
	static void setup(){
		// mockMailService = Mockito.mock(MailService.class);
		RestAssured.baseURI = "http://localhost:8080";
	}

	//Default test autogenerated by Spring Boot
	@Test
	void contextLoads() {
	}

	//First RestAssured test - Just makes sure getInbox() works as expected
	@Test
	void testGetInbox() {

		//Response object from RestAssured. Lets us extract and test HTTP Responses
		Response response = given()
				.when().get("/mail")
				.then().extract().response();

		//Now we can run assertions on the response
		response.then()
				.statusCode(200)
				.body("size()", greaterThan(0))
				.body("[0].sender", notNullValue())
				.body("[0].recipient", notNullValue());
	}

	//NOTE: We used JUnit, which is great and for Java tests in general...
	//But RestAssured is built SPECIFICALLY for testing REST APIs

	//Second RestAssured test - Tests success sendMail
	@Test
	void testSendMailSuccess(){

		//valid mail object
		Mail mail = new Mail("me@snailmail.com",
				"Testing",
				"you@snailmail.com",
				"Hi");

		//Same pattern as usual - gather the response, make assertions on it
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("/mail")
				.then().extract().response();

		response.then()
				.statusCode(200)
				.body("sender", equalTo("me@snailmail.com"));
				//TODO: we could check each field of course, but you get the point
	}

	//Third Test - sendMail fails with empty recipient
	@Test
	void testSendMailFailsOnMissingRecipient(){

		//Instantiate a mail object with a blank recipient
		Mail mail = new Mail("me@snailmail.com",
				"Testing",
				"",
				"Hi");

		//Same pattern as other tests-
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("/mail")
				.then()
				.extract().response();

		response.then()
				.statusCode(400) //bad request
				.body("error", equalTo("Recipient cannot be empty!"));
	}

	//Fourth Test - sendMail fails with subject > 20 characters
	@Test
	void testSendMailFailsOnSubjectOver20Chars(){

		//Instantiate a mail object with a long subject
		Mail mail = new Mail("me@snailmail.com",
				"Hey pal yesterday I had a ham sandwich and wouldn't you know it, I thought it was roast beef. Imagine my surprise! Anyway the sandwich was made with homemade rye bread, my mother's recipe actually. You should try it sometime.",
				"you@snailmail.com",
				"Hi");

		//Same pattern as other tests-
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("/mail")
				.then()
				.extract().response();

		response.then()
				.statusCode(400) //bad request
				.body("error", equalTo("Save it for the message body, buddy"));
	}

	//Fifth Test - login success (also adding two logging filters to this one!)
	@Test
	void successfulLoginCreatesNewSession(){

		//Define the JSON object for the request body
		String loginJson = """
				{
					"username": "username",
					"password": "password"
				}
				""";

		//Send the POST request, extract the response, assert stuff on it
		Response response = given()
				.filter(new RequestLoggingFilter()) //Log the request
				.filter(new ResponseLoggingFilter()) //Log the response
				.contentType("application/json")
				.body(loginJson)
				.when().post("/auth/login")
				.then().extract().response();

		//Assert 200 ok, assert session was set, assert user info is correct
		response.then()
				.statusCode(200)
				.body("username", equalTo("username"))
				.cookie("JSESSIONID", notNullValue());
	}

	//Sixth Test - use Mockito and MockMVC to test 204 on empty inbox

	@Test
	void returnsNoContentIfInboxIsEmpty() throws Exception {

		//Mock the service method call, and return null (simulates empty inbox)
		when(mockMailService.getInbox()).thenReturn(null);

		//Mock the HTTP request,
		//ensure the controller method does the right thing when inbox == null
		mockMvc.perform(get("/mail"))
				.andExpect(status().isNoContent()) //204 status code
				.andExpect(content().string("")); //Empty body

		//We've COMPLETELY isolated the controller logic
		//No real HTTP request was made, and no real service method was called
		//This is what it means to "test logic in isolation"

	}

	@Test
	void testChangePasswordSuccess(){

		//Define the JSON object for the request body
		String changePasswordAppropriateJson = """
			{
				"oldPassword": "password",
				"newPassword": "newPassword"
			}
			""";

		//Send the PATCH request, extract the response, assert stuff on it
		Response response = given()
					.contentType("application/json")
					.body(changePasswordAppropriateJson)
				.when()
					.patch("/user/password")
				.then()
					.extract()
					.response();

		//Assert 200 ok, assert the response body
		response.then()
				.statusCode(200)
				.body(equalTo("Password changed successfully"));

	}

	@Test
	void testChangePasswordFailsOnIncorrectOldPassword(){

		//Define the JSON object for the request body
		String changePasswordIncorrectJson = """
			{
				"oldPassword": "incorrect",
				"newPassword": "newPassword"
			}
			""";

		Response response = given()
				.contentType("application/json")
				.body(changePasswordIncorrectJson)
			.when()
				.patch("/user/password")
			.then()
				.extract()
				.response();

		// Assert 400 bad request
		response.then()
				.statusCode(400)
				.body(equalTo("Old password is incorrect!"));
	}
	
	@Test
	void testLoginIncorrectCredentials(){
		
		User incorrectCredentials = new User("incorrect-username", "incorrect@snailmail.com", "incorrect-password", "user");
		Response response = given()
					.contentType("application/json")
					.body(incorrectCredentials)
				.when()
					.post("/auth/login")
				.then()
					.extract()
					.response();
		response.then()
			.statusCode(401)
			.body(equalTo("Invalid username or password"));		
	}

	@Test
	void sendMailReturnsMailObjectOnSuccess() throws Exception {
	    // Arrange: create a Mail object and configure the mock service
	    Mail mail = new Mail("me@snailmail.com", "Test Subject", "you@snailmail.com", "Hello!");
	    when(mockMailService.sendMail(any(Mail.class))).thenReturn(mail);
	
	    // Convert the mail object to JSON (you can use Jackson's ObjectMapper)
	    String mailJson = """
	        {
	            "sender": "me@snailmail.com",
	            "subject": "Test Subject",
				"recipient": "you@snailmail.com",
				"body": "Hello!"
			}
	        """;

		// Act & Assert: perform the POST and check the response
		mockMvc.perform(
				post("/mail")
					.contentType("application/json")
					.content(mailJson)
			)
			.andExpect(status().isOk())
			.andExpect(content().json(mailJson));
	}
}
